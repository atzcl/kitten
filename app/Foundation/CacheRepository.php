<?phpdeclare(strict_types = 1);/*+-----------------------------------------------------------------------------------------------------------------------| Author: 植成樑 <atzcl0310@gmail.com>  Blog：https://www.atzcl.cn+-----------------------------------------------------------------------------------------------------------------------| 辅助重写 l5-repository 的缓存类|*/namespace App\Foundation;use Closure;class CacheRepository{    /**     * The Redis factory implementation.     *     * @var \Illuminate\Redis\Connections\Connection     */    protected $redis;    /**     * @var string 储存类别 [ id/where/list ]     */    public $storeType = 'id';    /**     * CacheRepository constructor.     *     * @return void     */    public function __construct()    {        $this->redis = app('redis');        // 设置默认缓存数据库        $this->setDatabase();    }    /**     * 获取缓存实例     *     * @return \Illuminate\Redis\Connections\Connection     */    public function getCacheInstance()    {        return $this->redis;    }    /**     * 切换 redis 数据库     *     * @param string|null $storeType     * @return $this     */    public function setDatabase(string $storeType = null)    {        $type = ! is_null($storeType) ? $storeType : $this->storeType;        // 切换到相应的数据库 [ id/where/list 分别对应不用的 redis 数据库 ]        $this->redis->select(            config('cache_repository.store_connection.' . $type, 0)        );        return $this;    }    /**     * Serialize the value.     *     * @param  mixed  $value     * @return mixed     */    public function serialize($value)    {        return is_numeric($value) ? $value : serialize($value);    }    /**     * Unserialize the value.     *     * @param  mixed  $value     * @return mixed     */    public function unserialize($value)    {        return is_numeric($value) ? $value : unserialize($value);    }    /**     * 判断缓存是否存在     *     * @param  string  $key 缓存标识     * @return bool     */    public function has(string $key)    {        return $this->redis->exists($key) !== 0 ? true : false;    }    /**     * 获取缓存     *     * @param string $key 缓存 key     * @return string     */    public function get(string $key)    {        $value = $this->redis->get($key);        return ! is_null($value) ? $this->unserialize($value) : null;    }    /**     * 设置缓存     *     * @param string $key 缓存 key     * @param int $minutes 缓存时间，单位：分     * @param mixed $value     * @return int     */    public function set(string $key, int $minutes, $value)    {        return $this->redis->setex(            $key,            (int) max(1, $minutes * 60),            $this->serialize($value)        );    }    /**     * 删除 key     * @param string | array $key     * @return int     */    public function forget($key)    {        return (bool) $this->redis->del($key);    }    /**     * 当缓存不存在的时候，通过执行闭包来缓存、返回结果     *     * @see /vendor/laravel/framework/src/Illuminate/Cache/Repository.php     *     * @param  string  $key 缓存 key     * @param  \DateTimeInterface|\DateInterval|float|int  $minutes 缓存过期时间     * @param  \Closure  $callback 回调     * @return mixed     */    public function remember(string $key, int $minutes, Closure $callback)    {        $value = $this->get($key);        // If the item exists in the cache we will just return this immediately and if        // not we will execute the given Closure and cache the result of that for a        // given number of minutes so it's available for all subsequent requests.        if (! is_null($value)) {            return $value;        }        $this->set($key, $minutes, $value = $callback());        return $value;    }    /**     * 根据缓存的存在情况执行对应的闭包     *     * @param string $key     * @param Closure $existCallback     * @param Closure $notExistCallback     * @return mixed|string     */    public function simpleRemember(string $key, Closure $existCallback, Closure $notExistCallback)    {        $value = $this->get($key);        return ! is_null($value) || !empty($value) ? $existCallback($value) : $notExistCallback();    }}